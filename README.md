Safe-Follow Symbolic Links
==========================

This is a Python package to help follow symlinks without falling into infinite
recursion. You can resolve individual paths, list directories (with any member
symlinks fully resolved), or walk entire directory trees.

Its `symlinkwalk.py` script can optionally be run as a command line tool.

Requirements
------------

Python 3.10 or later.

The package has no dependencies beyond the Standard Library.

`symlinkwalk.py` Executable Script
----------------------------------

Basic usage of the command line script would look something like this:

    > python3 symlinkwalk.py -r path foo
    d /full/path/to/foo

The `-r` option (short for `--resolve`) lets you set resolving mode to one of:

* `path`
  * prints the absolute path to `foo` with any symlinks resolved
* `list`
  * prints a listing of the `foo` directory, with one path per line
  * all member paths will be absolute and fully resolved
* `tree` (the default)
  * prints the entire directory tree rooted at `foo`
  * uses a depth-first traversal

### Output Format

Each path printed to the standard output is prefixed with a code followed by a
space. This code may be one of:

* `d`: path indicates an existing directory
* `f`: path indicates an existing non-directory
  * while most likely a file, it could be something more exotic (e.g. a device)
* `m`: file system object is missing at path
  * `foo` apparently does not exist
* `b`: path is to a broken symlink
  * whatever the symlink initially referenced no longer exists
  * say `foo` was a symlink and you asked to resolve `foo/bar`
    * if `foo` is broken, you will see `b /path/to/foo`
    * in other words, anything past the broken symlink is discarded
* `r`: path is a recursing symlink
  * wherever the link goes eventually winds up at the link itself
* `x`: path was exclude by an `--exclude` pattern
* `u#`: the same unique path was encountered multiple times
  * here, `#` is the number of times it was encountered â‰¥ 2
  * such entries only appear when `--unique-paths` is specified

Note that in the current implementation, for each target path, the entries are
printed in the following order:

* all `d` or `f` entries
* all `b` entries

### Target Path Arguments

You can supply more than one of these. Note, however, that this is essentially
equivalent to running the script multiple times with a single target each time.
For example, even with `--unique-paths`, you may see the same path appear from
walking different targets.

If you supply no paths, the current working directory will be chosen as the
target.

### As A Module

It can be imported into a Python project or run as a command line script.

As an imported module, the functionality is implemented in the
`class SymlinkWalk` together with the support classes for managing paths in
`support/pathref`. For more info, access the `pydoc`:

    python3 -m pydoc symlinkwalk
    python3 -m pydoc support/pathref.py

Alternatively, you can enter `python3 -m pydoc -b` to get the web server going.

For command line info, enter:

    python3 symlinkwalk.py --help

`support/pathref` Module
------------------------

This module defines a `class PathRef` which wraps several common
[path-like](https://docs.python.org/3/glossary.html#term-path-like-object)
types (and is itself path-like). These include:

* `str`
* `bytes`
* `pathlib.PurePath` (or any class from `pathlib`)
* `os.DirEntry`

It provides a number of properties and methods to move between these, as well
as a couple of subclasses generated by `SymlinkWalk` methods to indicate
missing paths or broken symlinks.
